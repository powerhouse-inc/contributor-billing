scalar Unknown
scalar DateTime
scalar Attachment
scalar Address
scalar Amount_Tokens
scalar EthereumAddress
scalar EmailAddress
scalar Amount_Percentage
scalar Date
scalar URL
scalar Amount_Money
scalar OLabel
scalar Currency
scalar PHID
scalar OID
scalar Amount_Fiat
scalar Amount_Currency
scalar Amount_Crypto
scalar Amount
scalar Upload

type SubscriptionInstanceState {
    customerId: PHID
    customerName: String
    customerEmail: EmailAddress
    customerWalletAddress: EthereumAddress
    customerType: CustomerType
    teamMemberCount: Int
    kycStatus: KycStatus
    operatorId: PHID
    serviceOfferingId: PHID
    tierName: String
    tierPricingOptionId: OID
    resource: ResourceDocument
    status: SubscriptionStatus!
    createdAt: DateTime
    activatedSince: DateTime
    pausedSince: DateTime
    expiringSince: DateTime
    renewalDate: DateTime
    cancelledSince: DateTime
    cancellationReason: String
    autoRenew: Boolean!
    operatorNotes: String
    budget: BudgetCategory
    services: [Service!]!
    serviceGroups: [ServiceGroup!]!
    invoices: [Invoice!]!
    communications: [CommunicationChannel!]!
}

enum CustomerType {
    INDIVIDUAL
    TEAM
}

enum KycStatus {
    NOT_REQUIRED
    NOT_STARTED
    PENDING
    VERIFIED
    REJECTED
}

type ServiceGroup {
    id: OID!
    optional: Boolean!
    name: String!
    services: [Service!]!
}

type ResourceDocument {
    id: PHID!
    label: String
    thumbnailUrl: URL
}

enum SubscriptionStatus {
    PENDING
    ACTIVE
    PAUSED
    EXPIRING
    CANCELLED
}

type RecurringCost {
    amount: Amount_Money!
    currency: Currency!
    billingCycle: BillingCycle!
    nextBillingDate: DateTime
    lastPaymentDate: DateTime
}

type SetupCost {
    amount: Amount_Money!
    currency: Currency!
    billingDate: DateTime
    paymentDate: DateTime
}

enum BillingCycle {
    MONTHLY
    QUARTERLY
    SEMI_ANNUAL
    ANNUAL
    ONE_TIME
}

type BudgetCategory {
    id: OID!
    label: String!
}

type Service {
    id: OID!
    name: String
    description: String
    setupCost: SetupCost
    recurringCost: RecurringCost
    metrics: [ServiceMetric!]!
}

type ServiceMetric {
    id: OID!
    name: String!
    unitName: String!
    limit: Int
    unitCost: RecurringCost
    currentUsage: Int!
    usageResetPeriod: ResetPeriod
    nextUsageReset: DateTime
}

enum ResetPeriod {
    HOURLY
    DAILY
    WEEKLY
    MONTHLY
    QUARTERLY
    SEMI_ANNUAL
    ANNUAL
}

type Invoice {
    id: OID!
    invoiceNumber: String!
    status: InvoiceStatus!
    periodStart: DateTime!
    periodEnd: DateTime!
    issueDate: DateTime!
    dueDate: DateTime!
    paidDate: DateTime
    subtotal: Amount_Money!
    tax: Amount_Money
    total: Amount_Money!
    currency: Currency!
    lineItems: [InvoiceLineItem!]!
    payments: [InvoicePayment!]!
    notes: String
}

enum InvoiceStatus {
    DRAFT
    SENT
    PAID
    PARTIALLY_PAID
    OVERDUE
    CANCELLED
    REFUNDED
}

type InvoiceLineItem {
    id: OID!
    description: String!
    serviceId: OID
    metricId: OID
    quantity: Int!
    unitPrice: Amount_Money!
    total: Amount_Money!
}

type InvoicePayment {
    id: OID!
    amount: Amount_Money!
    currency: Currency!
    paymentMethod: PaymentMethod!
    paymentDate: DateTime!
    transactionHash: String
    walletAddress: EthereumAddress
    reference: String
}

enum PaymentMethod {
    CRYPTO
    BANK_TRANSFER
    CREDIT_CARD
    PAYPAL
    OTHER
}

type CommunicationChannel {
    id: OID!
    type: CommunicationChannelType!
    identifier: String!
    isPrimary: Boolean!
    verifiedAt: DateTime
}

enum CommunicationChannelType {
    EMAIL
    TELEGRAM
    DISCORD
    SLACK
    WHATSAPP
}

# Subscription

input InitializeSubscriptionInput {
    customerId: PHID
    customerName: String
    customerEmail: EmailAddress
    serviceOfferingId: PHID
    tierName: String
    tierPricingOptionId: OID
    resourceId: PHID
    resourceLabel: String
    resourceThumbnailUrl: URL
    autoRenew: Boolean
    createdAt: DateTime!
}

input SetResourceDocumentInput {
    resourceId: PHID!
    resourceLabel: String
    resourceThumbnailUrl: URL
}

input UpdateSubscriptionStatusInput {
    status: SubscriptionStatus!
}

input ActivateSubscriptionInput {
    activatedSince: DateTime!
}

input PauseSubscriptionInput {
    pausedSince: DateTime!
}

input SetExpiringInput {
    expiringSince: DateTime!
}

input CancelSubscriptionInput {
    cancelledSince: DateTime!
    cancellationReason: String
}

input ResumeSubscriptionInput {
    timestamp: DateTime!
}

input RenewExpiringSubscriptionInput {
    timestamp: DateTime!
    newRenewalDate: DateTime
}

input SetBudgetCategoryInput {
    budgetId: OID!
    budgetLabel: String!
}

input RemoveBudgetCategoryInput {
    budgetId: OID!
}

input UpdateCustomerInfoInput {
    customerId: PHID
    customerName: String
    customerEmail: EmailAddress
}

input UpdateTierInfoInput {
    tierName: String
    tierPricingOptionId: OID
}

input SetOperatorNotesInput {
    operatorNotes: String
}

input SetAutoRenewInput {
    autoRenew: Boolean!
}

input SetRenewalDateInput {
    renewalDate: DateTime!
}

# Service

input AddServiceInput {
    serviceId: OID!
    name: String
    description: String
    setupAmount: Amount_Money
    setupCurrency: Currency
    setupBillingDate: DateTime
    setupPaymentDate: DateTime
    recurringAmount: Amount_Money
    recurringCurrency: Currency
    recurringBillingCycle: BillingCycle
    recurringNextBillingDate: DateTime
    recurringLastPaymentDate: DateTime
}

input RemoveServiceInput {
    serviceId: OID!
}

input UpdateServiceSetupCostInput {
    serviceId: OID!
    amount: Amount_Money
    currency: Currency
    billingDate: DateTime
    paymentDate: DateTime
}

input UpdateServiceRecurringCostInput {
    serviceId: OID!
    amount: Amount_Money
    currency: Currency
    billingCycle: BillingCycle
    nextBillingDate: DateTime
    lastPaymentDate: DateTime
}

input ReportSetupPaymentInput {
    serviceId: OID!
    paymentDate: DateTime!
}

input ReportRecurringPaymentInput {
    serviceId: OID!
    paymentDate: DateTime!
}

input UpdateServiceInfoInput {
    serviceId: OID!
    name: String
    description: String
}

# Service Group

input AddServiceGroupInput {
    groupId: OID!
    name: String!
    optional: Boolean!
}

input RemoveServiceGroupInput {
    groupId: OID!
}

input AddServiceToGroupInput {
    groupId: OID!
    serviceId: OID!
    name: String
    description: String
    setupAmount: Amount_Money
    setupCurrency: Currency
    setupBillingDate: DateTime
    setupPaymentDate: DateTime
    recurringAmount: Amount_Money
    recurringCurrency: Currency
    recurringBillingCycle: BillingCycle
    recurringNextBillingDate: DateTime
    recurringLastPaymentDate: DateTime
}

input RemoveServiceFromGroupInput {
    groupId: OID!
    serviceId: OID!
}

# Metrics

input AddServiceMetricInput {
    serviceId: OID!
    metricId: OID!
    name: String!
    unitName: String!
    limit: Int
    currentUsage: Int!
    usageResetPeriod: ResetPeriod
    nextUsageReset: DateTime
    unitCostAmount: Amount_Money
    unitCostCurrency: Currency
    unitCostBillingCycle: BillingCycle
    unitCostNextBillingDate: DateTime
    unitCostLastPaymentDate: DateTime
}

input UpdateMetricInput {
    serviceId: OID!
    metricId: OID!
    name: String
    unitName: String
    limit: Int
    usageResetPeriod: ResetPeriod
    nextUsageReset: DateTime
}

input UpdateMetricUsageInput {
    serviceId: OID!
    metricId: OID!
    currentTime: DateTime!
    currentUsage: Int!
}

input RemoveServiceMetricInput {
    serviceId: OID!
    metricId: OID!
}

input IncrementMetricUsageInput {
    serviceId: OID!
    metricId: OID!
    currentTime: DateTime!
    incrementBy: Int!
}

input DecrementMetricUsageInput {
    serviceId: OID!
    metricId: OID!
    currentTime: DateTime!
    decrementBy: Int!
}

# Billing

input CreateInvoiceInput {
    invoiceId: OID!
    invoiceNumber: String!
    periodStart: DateTime!
    periodEnd: DateTime!
    issueDate: DateTime!
    dueDate: DateTime!
    currency: Currency!
    notes: String
}

input UpdateInvoiceStatusInput {
    invoiceId: OID!
    status: InvoiceStatus!
    paidDate: DateTime
}

input AddInvoiceLineItemInput {
    invoiceId: OID!
    lineItemId: OID!
    description: String!
    serviceId: OID
    metricId: OID
    quantity: Int!
    unitPrice: Amount_Money!
}

input RemoveInvoiceLineItemInput {
    invoiceId: OID!
    lineItemId: OID!
}

input SetInvoiceTaxInput {
    invoiceId: OID!
    tax: Amount_Money!
}

input RecordInvoicePaymentInput {
    invoiceId: OID!
    paymentId: OID!
    amount: Amount_Money!
    currency: Currency!
    paymentMethod: PaymentMethod!
    paymentDate: DateTime!
    transactionHash: String
    walletAddress: EthereumAddress
    reference: String
}

input SendInvoiceInput {
    invoiceId: OID!
    sentDate: DateTime!
}

input CancelInvoiceInput {
    invoiceId: OID!
    reason: String
}

input MarkInvoiceOverdueInput {
    invoiceId: OID!
}

input RefundInvoiceInput {
    invoiceId: OID!
    refundDate: DateTime!
    reason: String
}

# Customer

input UpdateCustomerWalletInput {
    walletAddress: EthereumAddress
}

input SetCustomerTypeInput {
    customerType: CustomerType!
    teamMemberCount: Int
}

input UpdateTeamMemberCountInput {
    teamMemberCount: Int!
}

input UpdateKycStatusInput {
    kycStatus: KycStatus!
}

input AddCommunicationChannelInput {
    channelId: OID!
    type: CommunicationChannelType!
    identifier: String!
    isPrimary: Boolean!
    verifiedAt: DateTime
}

input RemoveCommunicationChannelInput {
    channelId: OID!
}

input SetPrimaryCommunicationChannelInput {
    channelId: OID!
}

input VerifyCommunicationChannelInput {
    channelId: OID!
    verifiedAt: DateTime!
}